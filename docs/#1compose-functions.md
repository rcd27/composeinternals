#### Значение `Composable` функций

Пожалуй, наиболее адекватным началом для данной книги будет изучение функций, являющихся основными "
кирпичиками" при построения приложений с помощью `Compose`
С помощью этих функций выстраиваются деревья, листиками которых являются сами функции. Любая
котлинячая функция может стать компоузаблом при добавлении аннотации `@Composable`. При добавлении
аннотации мы говорим компилятору, что в данной функции будут использованы данные, которые надо
перевести в ноду при регистрации компоузабл дерева.

```kotlin
@Composable(Input) -> Unit
```

Где данными будет `Input` и результатом будет `Unit`, что говорит нам о сайд эффекте. Такой
сайд-эффект в компоузе называется `emitting`(далее - эмит). Компоузабл функции эмитят при
выполнении. Говоря далее "компоузится" мы будем подразумевать "выполняются". Единственная задача
выполнения компоузабл функций - построить или обновить `in-memory` представление дерева. Это дерево
будет обновляться при изменении данных, "рекомпоузиться". Ноды могут обновляться, удаляться,
вставляться новые (обновление состояний нод - включено)

#### Параметры `Composable` функций

Аннотация `@Composable` эффективно __меняет тип функций__ или выражений, к которым применена, и, как
и любой другой тип, накладывает определённые ограничения. Эти ограничения очень тесно связаны
с `Jetpack Compose`(видимо, имеется в виду именно `Compose Runtime`), так как они открывают доступ
ко всем её возможностям. Рантайм компоуза накладывает эти ограничения, так как ему надо реализовать
определённое поведение таких блоков, помимо оптимизаций и параллельной композиции/рекомпозиции (
опираясь на параметры, приоритеты, "умные рекомпозиции" и пр.)

#### Вызывающий контекст(calling context)

Большинство параметров функции доступны компилятору компоуза. Так как это котлинячий компиляторный
плагин, то всё разруливается в компайл-тайме благодаря бэк-енду компилятора(во время всех фаз
компиляции). Это позволяет трансформировать `IR`(intermediate representation) всех компоузовских
функций для того, чтобы добавить в них доп.инфу.

Один из параметров, который добавляется - `Composer` (добавляется прям в аргументы фунцкии, в конец
списка). Он явный, разработчикам не нужно напрямую с ним возиться. Инстанс композера инжектиться при
рантайме и пробрасывается по всему дереву компоузаблов, каждая нода из этого дерева имеет к нему
доступ.

Если у нас было что-то типа

```kotlin
@Composable
fun NamePlate(name: String, lastname: String) {
    Text(text = name)
    Text(text = lastName)
}
```

То после компиляции станет

```kotlin
@Composable
fun NamePlate(name: String, lastname: String, $composer: Composer<*>) {
    Text(
        text = name,
        $composer
    )
    Text(
        text = lastName,
        $composer
    )
}
```

Тут видно, что `Composer` прокидывается вниз по нодам. В этой связи компилятор компоуза накладывает
обязательное правило: `@Composable` функции могут быть вызваны только из других `@Composable`
функций. Это и есть "calling context"(контекст, необходимый для вызова `@Composable` функций).
Все `Composable` функции будут использовать `Composer` в рантайме для того, чтобы обновлять стэйт
дерева.

#### Идемпотентность

Вызов компоузаблов множество раз с одними и теми же аргументами должен давать один и тот же
результат(о, эт мы любим в функциональщине). Рантайм компоуза жёстко расчитывает на такую
индемпотентность.

Рекомпоуз (`recomposition`) - це повторные вызовы функции в случае, когда аргументы(данные)
изменились с тем, чтобы они могли заэмитить свой новый стэйт и дерево обновилось(ничё не напоминает,
не? например, реактивщину)

Такая рекомпозиция спускается по дереву, проверяя, какие из нод требуют повторного вызова(
рекомпоуза). Только те ноды, которые получили на вход новые данные, будут рекомпозированы. Остальные

- __скипнут__.

#### Свободные от неконтролируемых сайд-эффектов

Сайд-эффект - это любое действие, выходящее за рамки функции (смена значения в поле класса,
например). Чтение из кэша, сетевой запрос / БД - эт всё сайд-эффекты. Проще говоря, функция при
одних и тех же аргументах может выдавать разные результаты. Если впиливать такие вещи в компоузаблы,
то рантайму это не очень понравится, потому как тот ожидает, что может многократно "перезапускать"
ноду совершенно безопасно. Добавим сюда то, что рекомпоуз может вызывться из разных потоков.
Соответственно, сайд-эффекты(типа запроса в сеть) - повалятся нахуй без всякой координации.

Рантайм компоуза оставляет за собой право выбирать, когда вызывать `@Composable` функции. В том
числе, сколько и каких ядер для этого использовать. В каком порядке вызывать и прочее (ну, например,
компоузаблы, которые не отображаются на экране - получают низкий приоритет рекомпоуза)

Короче говоря, надо стараться избегать любых сайд-эффектов в компоузаблах, делать их максимально
тупыми и зависящими только от входных аргументов функции.

Но так как нам в конечном счёте без сайд-эффектов не обойтись, то для этого в компоузе
есть `effect handler`ы. Эти парни выносят наши сайд-эффекты за скоуп компоуза так, что им пофиг на
жизненный цикл компоуза. Так же позволяют отменить выполнение, отписаться и многое другое.

#### Перезапускаемость

В привычном смысле - каждая рекомпоузабл функция - не совсем "обычная". Мы-то всегда ждём, что наши
функции вызываются столько раз, сколько мы написали. Но в случае с `Compose` - это решать не нам. Не
хочешь, чтобы она перезапускалась, не меняй данные(грубо говоря)

#### Быстрое исполнение

О дереве `Composable` функций можно смело думать, как о быстром, декларативном и легковесном способе
описания программы, которая интерпретируется (материализуется) с течением времени.

Важно: `Composable` функции не рисуют `UI`(вот это поворот, да?). Всё, что они делают - эмитят
данные для того, чтобы обновить состояние в памяти. Это делает их очень шустрыми и позволяет
рантайму дёргать их постоянно без всяких опасений. Иногда это происходит весьма часто, например: для
каждого кадра, если речь идёт об анимации.

Разрабы должны держать это в уме, поэтому каждая долгоиграющая таска требует вывода её в корутины и
обёртки в `effect handler`(ну ты понял, да, чтобы каждый раз не запускать эту барибу при рекомпоузе)

#### Мемоизация(да, придётся загуглить, и вообще, у нас тут типа ФП) позиции

Мемоизация(короче запоминание) позиции - форма мемеизации функций. Это способность кэшировать
результат выполнения функции для одних и тех же инпутов. Это позволяет тупо доставать из кэша ранее
высчитаный результат, если на вход прилетел тот же самый аргумент(возможно только в случае чистой
функции, от пер.).

В случае с компоузом, мемоизация происходит с учётом `id`, которые были присвоены каждому параметру.

```kotlin
@Composable
fun OhMy() {
    Text("Hello") // id 1
    Text("Hello") // id 2
    Text("Hello") // id 3
}
```

Каждому стрингу `Hello` будет присвоен свой личный айдишник, который будет учитываться при
рекомпозиции(ну или скипать рекомпозицию, если данные не изменились).

Иногда композу сложно проставить айдишники (ну, например, в случае с листом)

```kotlin
@Composable
fun TasksScreen(tasks: List<Task>) {
    Column {
        for (task in tasks) {
            Text(text = task.name)
        }
    }
}
```

В таком случае компоуз опирается на __порядок вызовов__ для того, чтобы сгенерить уникальные
айдишники и мочь их различить. Это отлично работает, если добавить элемент в конец списка. Но
вызовет рекомпозицию всего "хвоста"(всех элементов после), если сунуть новый - в середину списка
например. Это произойдёт потому, что все элементы хвоста "сменили свою позицию". Ататат, ведь можно
было скипнуть их рекомпозицию, верно? Для таких случаев есть инструмент `key`, зырь:

```kotlin
@Composable
fun TasksScreen(tasks: List<Task>) {
    Column {
        for (task in tasks) {
            key(task.id) { // уникальный компоузовский ключ
                Text(text = task.name)
            }
        }
    }
}
```

При использовании ключа `key` рекомпозиция будет игнорировать изменение позиции.

Весь компоуз строится на данном механизме мемоизации с возможностью скипнуть рекомпозицию.

Иногда разрабам нужен доступ к этой `in-memory` структуре в отрыве от `Composable` функции.
Например, нам нужно закешировать результат каких-то "тяжёлых" вычислений, которые происходят в
скоупе функции. Для таких развлечений в компоузе есть функция `remember`:

```kotlin
@Composable
fun FilteredImage(path: String) {
    val filters = remember { computeFilters(path) }
    ImageWithFilters(filters)
}
```

`key` для индексирования закешированного значения будет основан на месте вызова в коде, а также на
аргументах функции, в данном случае - `path`. Функция `remember` - это просто компоуз функция,
которая знает как записывать и читать из `in-memory` структуры, содержащей в себе состояние дерева.
Единственное, что она делает - раскрывает разрабам механизм `positional memoization`.

Мемоизация в компоузе не распространяется на всё приложение. Когда что-то кешируется, это происходит
только в контексте функции, где это вызывается. В примере выше - только в скоупе `FilteredImage`. На
деле, компоуз рантайм пойдёт в оперативку и будет искать там данные в пределах "слотов", в которых
эта функция определена. Можно сказать, что это локальный синглтон. Если бы функция `FilteredImage`
была использована ещё в каком-то месте(ноде), то отдельный её "инстанс" соответственно был бы
размещён в другом месте в памяти.

#### Сходства с `suspended` функциями

В `Kotlin` `suspend` функции тоже могут быть вызваны только из других `suspend` функций, поэтому
можно сказать, что они тоже требуют свой определённый контекст для их вызова. Короче говоря, очень
похожий механизм, только там пробрасывается аргумент типа `Continuation`, бариба, которая нужна
рантайму, чтобы отложить/возобновить выполнение функции из других асинхронных частей программы.
Таким образом получается дерево выполненяемых функций.

В таком же стиле реализован и `@Composable`, он добавляет возможность перезапустить, реактивность и
прочее.

// p.28