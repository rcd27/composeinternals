#### Значение `Composable` функций
Пожалуй, наиболее адекватным началом для данной книги будет изучение функций, являющихся основными "кирпичиками" при построения приложений с помощью `Compose`
С помощью этих функций выстраиваются деревья, листиками которых являются сами функции.
Любая котлинячая функция может стать компоузаблом при добавлении аннотации `@Composable`. При добавлении аннотации мы говорим компилятору, что в данной функции будут использованы данные, которые надо перевести в ноду при регистрации компоузабл дерева.
```kotlin
@Composable (Input) -> Unit
```
Где данными будет `Input` и результатом будет `Unit`, что говорит нам о сайд эффекте. Такой сайд-эффект в компоузе называется `emitting`(далее - эмит). Компоузабл функции эмитят при выполнении. Говоря далее "компоузится" мы будем подразумевать "выполняются".
Единственная задача выполнения компоузабл функций - построить или обновить `in-memory` представление дерева. Это дерево будет обновляться при изменении данных, "рекомпоузиться". Ноды могут обновляться, удаляться, вставляться новые (обновление состояний нод - включено)

#### Параметры `Composable` функций
Аннотация `@Composable` эффективно __меняет тип функций__ или выражений, к которым применена, и, как и любой другой тип, накладывает определённые ограничения. Эти ограничения очень тесно связаны с `Jetpack Compose`(видимо, имеется в виду именно `Compose Runtime`), так как они открывают доступ ко всем её возможностям.
Рантайм компоуза накладывает эти ограничения, так как ему надо реализовать определённое поведение таких блоков, помимо оптимизаций и параллельной композиции/рекомпозиции (опираясь на параметры, приоритеты, "умные рекомпозиции" и пр.)

#### Вызывающий контекст(calling context) 
Большинство параметров функции доступны компилятору компоуза. Так как это котлинячий компиляторный плагин, то всё разруливается в компайл-тайме благодаря бэк-енду компилятора(во время всех фаз компиляции). Это позволяет трансформировать `IR`(intermediate representation) всех компоузовских функций для того, чтобы добавить в них доп.инфу.

Один из параметров, который добавляется - `Composer` (добавляется прям в аргументы фунцкии, в конец списка). Он явный, разработчикам не нужно напрямую с ним возиться. Инстанс композера инжектиться при рантайме и пробрасывается по всему дереву компоузаблов, каждая нода из этого дерева имеет к нему доступ.

Если у нас было что-то типа
```kotlin
@Composable
fun NamePlate(name:String, lastname: String) {
    Text(text = name)
    Text(text = lastName)
}
```

То после компиляции станет
```kotlin
@Composable
fun NamePlate(name:String, lastname: String, $composer: Composer<*>) {
    Text(
        text = name,
        $composer
    )
    Text(
        text = lastName,
        $composer
    )
}
```

Тут видно, что `Composer` прокидывается вниз по нодам. В этой связи компилятор компоуза накладывает обязательное правило: `@Composable` функции могут быть вызваны только из других `@Composable` функций. Это и есть "calling context"(контекст, необходимый для вызова `@Composable` функций). Все `Composable` функции будут использовать `Composer` в рантайме для того, чтобы обновлять стэйт дерева.

#### Идемпотентность
Вызов компоузаблов множество раз с одними и теми же аргументами должен давать один и тот же результат(о, эт мы любим в функциональщине). Рантайм компоуза жёстко расчитывает на такую индемпотентность.

Рекомпоуз (`recomposition`) - це повторные вызовы функции в случае, когда аргументы(данные) изменились с тем, чтобы они могли заэмитить свой новый стэйт и дерево обновилось(ничё не напоминает, не? например, реактивщину)

Такая рекомпозиция спускается по дереву, проверяя, какие из нод требуют повторного вызова(рекомпоуза). Только те ноды, которые получили на вход новые данные, будут рекомпозированы. Остальные - __скипнут__. 
